# -*- coding: utf-8 -*-
"""Assign1 q5-q9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tW3lZ8uMZf-xU79Uv8sPkQ_cSt703q00

# **5-A Normalizing the data sets**
"""

import numpy as np
import csv
from matplotlib import pyplot as plt
from random import randint, randrange, random
import time

"""Geenrating data in uniform  distribution and storing in `ud.txt`"""

UD = []
for i in range(17):
  UD.append(np.random.uniform(low=0, high = 1, size= 2**i))
with open("/content/drive/MyDrive/Algo Lab/ud1.txt", "w") as ud:
    csv.writer(ud, delimiter=' ').writerows(UD)

"""Geenrating data in normal distribution and storing in `nd.txt`"""

ND = []
for i in range(17): 
  ND.append(np.random.random(2**i))

with open("/content/drive/MyDrive/Algo Lab/nd1.txt", "w") as nd:
    csv.writer(nd, delimiter=' ').writerows(ND)

"""# **5-b Bucket Sort**

Implementing the BucketSort and checking for the correctness
"""

def insertionSort(b):
    for i in range(1, len(b)):
        up = b[i]
        j = i - 1
        while j >= 0 and b[j] > up:
            b[j + 1] = b[j]
            j -= 1
        b[j + 1] = up    
    return b    
                      
def bucketSort(x):
    arr = []
    slot_num = 10 # 10 means 10 slots, each slot's size is 0.1
    for i in range(slot_num):
        arr.append([])
    for j in x:
        index_b = int(slot_num * j)
        arr[index_b].append(j)
    for i in range(slot_num):
        arr[i] = insertionSort(arr[i])
    k = 0
    for i in range(slot_num):
        for j in range(len(arr[i])):
            x[k] = arr[i][j]
            k += 1
    return x

print(bucketSort([0.3, 0.5, 0.1, 0.125, 0.178]))

"""# **6. Complexity of Bucket Sort**

*   Opening the files "ud1.txt" and "nd1.txt"
*   Storing the data in lists `ud` and `nd`
* `time_uniform` for storing the time taken in uniform distribution
* `time_normal` for storing the time taken in normal distribution
"""

ud = open('/content/drive/MyDrive/Algo Lab/ud1.txt', 'r')
nd = open('/content/drive/MyDrive/Algo Lab/nd1.txt', 'r')
uniform_data = [line.rstrip() for line in ud]
normal_data = [line.rstrip() for line in nd]
time_uniform = [[], []]
time_normal = [[], []]

"""Experimenting with Bucket sort and collecting the data for uniform distribution"""

for x in uniform_data:
  arr = list(map(float, x.split()))
  begin = time.time()
  bucketSort(arr)
  end = time.time()
  time_uniform[0].append(len(arr))
  time_uniform[1].append(end-begin)

"""Plotting Time taken for BucketSort(Uniform Distribution)"""

plt.plot(time_uniform[0], time_uniform[1], color = '#58b970', label = 'Time taken Bucket Sort Uniform')
plt.xlabel('size')
plt.ylabel('Time')
plt.show()

"""Experimenting with Bucket sort and collecting the data for normal distribution"""

for x in normal_data:
  arr = list(map(float, x.split()))
  begin = time.time()
  bucketSort(arr)
  end = time.time()
  time_normal[0].append(len(arr))
  time_normal[1].append(end-begin)

"""Plotting Time taken for BucketSort(Normal Distribution)"""

plt.plot(time_normal[0], time_normal[1], color = '#58b970', label = 'Time taken Bucket Sort Normal')
plt.xlabel('size')
plt.ylabel('Time')
plt.show()

"""# **7.Median of Medians Algorithm**

Implementing the Median of Medians Algorithm and checking for the correctness
"""

def findMedian(a, p, r):
    L = []
    for i in range(p, r+1):
        L.append(a[i])
    L.sort()
    return L[(len(L)//2)]

def KthSmallest(a, p, r, k):
    n = r - p + 1
    median = []
    i = 0
    while i < n//5:
        median.append(findMedian(a, p+5*i, p+5*i+4))
        i += 1
    if i*5 < n:
        median.append(findMedian(a, p+5*i, p+5*i+(n%5-1)))
        i += 1
    if i == 1:
        medOfmed = median[i-1]
    else:
        medOfmed = KthSmallest(median, 0, i-1, i//2)
    q = partition(a, p, r, medOfmed)
    i = q - p + 1 
    if i == k:
        return a[q]
    elif i > k:
        return KthSmallest(a, p, q-1, k)
    else:
        return KthSmallest(a, q+1, r, k-i)

"""Implementing the QuickSort with pivot as Median of Medians"""

def partition(a, p, r, x):
    for i in range(p, r+1): 
        if a[i] == x: 
            a[i], a[r] = a[r], a[i]
            break
    i = p - 1
    for j in range(p, r):
        if a[j] <= a[r]:
            i += 1 
            a[i], a[j] = a[j], a[i]
    a[i+1], a[r] = a[r], a[i+1]
    return i+1

def QuickSort(a, p, r):
    if p >= r:
        return 
    med = KthSmallest(a, p, r, (r-p+1)//2)
    q = partition(a, p, r, med)
    QuickSort(a, p, q-1)
    QuickSort(a, q+1, r)

l = [1,5,6,8,9,2,4]
QuickSort(l, 0, len(l)-1)
print(l)

"""# **8. Different sizes for selecting medians**

Selecting the Median of Medians for different sizes
"""

def KthSmallest_new(a, p, r, k, s):
    n = r - p + 1
    median = []
    i = 0
    while i < n//s:
        median.append(findMedian(a, p+s*i, p+s*i+s-1))
        i += 1
    if i*s < n:
        median.append(findMedian(a, p+s*i, p+s*i+(n%s-1)))
        i += 1
    if i == 1:
        medOfmed = median[i-1]
    else:
        medOfmed = KthSmallest_new(median, 0, i-1, i//2, s)
    q = partition(a, p, r, medOfmed)
    i = q - p + 1 
    if i == k:
        return a[q]
    elif i > k:
        return KthSmallest_new(a, p, q-1, k, s)
    else:
        return KthSmallest_new(a, q+1, r, k-i, s)

def Quick_Sort(a, p, r, s):
    if p >= r:
        return 
    med = KthSmallest_new(a, p, r, (r-p+1)//2, s)
    q = partition(a, p, r, med)
    Quick_Sort(a, p, q-1, s)
    Quick_Sort(a, q+1, r, s)

"""

*   Opening the files "ud1.txt" and "nd1.txt"
*   Storing the data in lists `ud` and `nd`
* `time_uniform_3` for storing the time taken in uniform distribution with MoM size 3
* `time_normal_3` for storing the time taken in normal distribution with MoM size 3
* `time_uniform_5` for storing the time taken in uniform distribution with MoM size 5
* `time_normal_5` for storing the time taken in normal distribution with MoM size 5
* `time_uniform_7` for storing the time taken in uniform distribution with MoM size 7
* `time_normal_7` for storing the time taken in normal distribution with MoM size 7


"""

ud = open('/content/drive/MyDrive/Algo Lab/ud.txt', 'r')
nd = open('/content/drive/MyDrive/Algo Lab/nd.txt', 'r')
uniform_data = [line.rstrip() for line in ud]
normal_data = [line.rstrip() for line in nd]
time_uniform_3 = [[], []]
time_normal_3 = [[], []]
time_uniform_5 = [[], []]
time_normal_5 = [[], []]
time_uniform_7 = [[], []]
time_normal_7 = [[], []]

"""Experimenting with QuickSort and collecting the data for uniform distribution with different sizes of MoM"""

for i in range(len(uniform_data)):
  arr = list(map(float, uniform_data[i].split()))
  begin = time.time()
  Quick_Sort(arr, 0, len(arr)-1, 3)
  end = time.time()
  time_uniform_3[0].append(len(arr))
  time_uniform_3[1].append(end-begin)

for i in range(len(uniform_data)):
  arr = list(map(float, uniform_data[i].split()))
  begin = time.time()
  Quick_Sort(arr, 0, len(arr)-1, 5)
  end = time.time()
  time_uniform_5[0].append(len(arr))
  time_uniform_5[1].append(end-begin)

for i in range(len(uniform_data)):
  arr = list(map(float, uniform_data[i].split()))
  begin = time.time()
  Quick_Sort(arr, 0, len(arr)-1, 7)
  end = time.time()
  time_uniform_7[0].append(len(arr))
  time_uniform_7[1].append(end-begin)

"""Plotting Time taken for QuickSort(Uniform Distribution) with different sizes of MoM"""

plt.plot(time_uniform_3[0], time_uniform_3[1], color = 'r', label = 'size = 3')
plt.plot(time_uniform_5[0], time_uniform_5[1], color = 'g', label = 'size = 5')
plt.plot(time_uniform_7[0], time_uniform_7[1], color = 'b', label = 'size = 7')
plt.legend()
plt.show()

"""Experimenting with Quicksort and collecting the data with different MoM in normal distribution"""

for i in range(len(normal_data)):
  arr = list(map(float, normal_data[i].split()))
  begin = time.time()
  Quick_Sort(arr, 0, len(arr)-1, 3)
  end = time.time()
  time_normal_3[0].append(len(arr))
  time_normal_3[1].append(end-begin)

for i in range(len(normal_data)):
  arr = list(map(float, normal_data[i].split()))
  begin = time.time()
  Quick_Sort(arr, 0, len(arr)-1, 5)
  end = time.time()
  time_normal_5[0].append(len(arr))
  time_normal_5[1].append(end-begin)

for i in range(len(normal_data)):
  arr = list(map(float, normal_data[i].split()))
  begin = time.time()
  Quick_Sort(arr, 0, len(arr)-1, 7)
  end = time.time()
  time_normal_7[0].append(len(arr))
  time_normal_7[1].append(end-begin)

"""Plotting Time taken for QuickSort with different sizes of MoM"""

plt.plot(time_normal_3[0], time_normal_3[1], color = 'r', label = 'size = 3')
plt.plot(time_normal_5[0], time_normal_5[1], color = 'g', label = 'size = 5')
plt.plot(time_normal_7[0], time_normal_7[1], color = 'b', label = 'size = 7')
plt.legend()
plt.show()

"""#**9 - Rearranging the elements of the datasets (both UD and ND) and**
#**observing the partition or split obtained using the pivotal element chosen as MoM**
"""

ud = open('/content/drive/MyDrive/Algo Lab/ud.txt', 'r')
nd = open('/content/drive/MyDrive/Algo Lab/nd.txt', 'r')
uniform_data = [line.rstrip() for line in ud]
normal_data = [line.rstrip() for line in nd]
udata, ndata = [], []

import sys
sys.setrecursionlimit(2500)

def select(L):
    if len(L) < 10:
        L.sort()
        return L[int(len(L)/2)]
    S = []
    lIndex = 0
    while lIndex+5 < len(L)-1:
        S.append(L[lIndex:lIndex+5])
        lIndex += 5
    S.append(L[lIndex:])
    Meds = []
    for subList in S:
        #print(subList)
        Meds.append(select(subList))
    L2 = select(Meds)
    L1 = L3 = []
    for i in L:
        if i < L2:
            L1.append(i)
        if i > L2:
            L3.append(i)
    if len(L) < len(L1):
        return select(L1)
    elif len(L) > len(L1) + 1:
        return select(L3)
    else:
        return L2

"""Shuffling the data sets"""

for x in uniform_data:
  arr = list(map(float, x.split()))
  np.random.shuffle(arr)
  MoM = select(arr)
  arr.sort()
  ind = arr.index(MoM)
  udata.append(abs((len(arr))//2 - ind-1))

print(udata)

for x in normal_data:
  arr = list(map(float, x.split()))
  np.random.shuffle(arr)
  MoM = select(arr)
  arr.sort()
  ind = arr.index(MoM)
  ndata.append(abs((len(arr))//2 - ind-1))

print(ndata)

plt.plot(udata)
plt.show()

"""![image.png](data:image/png;base64,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)

The split obtained when we take MoM as pivotal element is almost near to half and it is very far from the worst case. We can guarantee the O(nlogn) complexity if we choose MoM as pivotal element. In the worst case the MoM is 415 elements away incase of normal distribution data
"""

plt.plot(ndata)
plt.show()

"""![image.png](data:image/png;base64,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)

The split obtained when we take MoM as pivotal element is almost near to half and it is very far from the worst case. We can guarantee the O(nlogn) complexity if we choose MoM as pivotal element. In the worst case the MoM is 564 elements away incase of normal distribution data
"""